### 1. 锁定机制

> 数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则，是由存储引擎各自所面对的特定场景二优化设计的

| 锁定机制 | 使用存储引擎                       | 特性                                         |
| ---- | ---------------------------- | ------------------------------------------ |
| 表级锁定 | MyISAM，MEMORY，CSV等一些非事务性存储引擎 | 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低      |
| 行级锁定 | InnoDB                       | 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高     |
| 页级锁定 | BerkeleyDB                   | 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般 |

从锁的角度适用来说：

    表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统

### 2. Innodb 行级锁定

#### 2.1 锁定模式

意向锁：让行级锁定和表级锁定共存，且自动添加的，无需用户干预

| ---       | 共享锁（S） | 排他锁（X） | 意向共享锁（IS） | 意向排他锁（IX） |
| --------- | ------ | ------ | --------- | --------- |
| 共享锁（S）    | 兼容     | 冲突     | 兼容        | 冲突        |
| 排他锁（X）    |        | 冲突     | 冲突        | 冲突        |
| 意向共享锁（IS） |        |        | 兼容        | 兼容        |
| 意向排他锁（IX） |        |        |           | 兼容        |

    如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。

    对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁，但可通过以下方式主动加锁

```sql
# 共享锁（S）
SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE

# 排他锁（X)
SELECT * FROM table_name WHERE ... FOR UPDATE
```

#### 2.2 Innodb 行锁

##### 2.2.1 锁特性

> 是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁

使用实际例子：

* 不通过索引条件查询时，Innodb使用表锁

* innodb行锁是针对索引加的锁，即如果访问不同行的数据，也存在锁冲突问题（使用相同的索引键）

* 当表有多个索引时，不同的事务可以使用不同的索引锁定不同的行，另外行锁不区分索引类型

* 即便在条件中使用了索引字段，最终还是由explain执行计划的代价来决定的

##### 2.2.2 间隙锁（Next-Key）

###### 1. 定义

    当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁

###### 2. 使用间隙锁目的

* 防止幻读，以满足相关隔离级别的要求

* 满足其恢复和复制的需要

#### 2.3 行锁优化建议

###### 2.3.1 扬长避短

1. 尽可能让所有的数据检索都通过索引来完成，从而避免InnoDB因为无法通过索引键加锁而升级为表级锁定

2. 合理设计索引，让InnoDB在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他Query的执行

3. 尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录

4. 尽量控制事务的大小，减少锁定的资源量和锁定时间长度

5. 在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少MySQL因为实现事务隔离级别所带来的附加成本
   
   

###### 2.3.2 减少发生概率

1. 在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少MySQL因为实现事务隔离级别所带来的附加成本

2. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率

3. 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率



###### 2.3.3 查看系统状态变量

```sql
mysql> show status like 'InnoDB_row_lock%';
+-------------------------------+-------+
| Variable_name                 | Value |
+-------------------------------+-------+
| InnoDB_row_lock_current_waits | 0     |
| InnoDB_row_lock_time          | 0     |
| InnoDB_row_lock_time_avg      | 0     |
| InnoDB_row_lock_time_max      | 0     |
| InnoDB_row_lock_waits         | 0     |
+-------------------------------+-------+
```

对各个状态量的说明如下：

　　InnoDB_row_lock_current_waits：当前正在等待锁定的数量
　　InnoDB_row_lock_time：从系统启动到现在锁定总时间长度
　　InnoDB_row_lock_time_avg：每次等待所花平均时间
　　InnoDB_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间
　　InnoDB_row_lock_waits：系统启动后到现在总共等待的次数


　　对于这5个状态变量，比较重要的主要是InnoDB_row_lock_time_avg（等待平均时长），InnoDB_row_lock_waits（等待总次数）以及InnoDB_row_lock_time（等待总时长）这三项



#### 2.4 表锁使用场景

##### 2.4.1 使用场景

> 当然应用中这两种事务不能太多，否则，就应该考虑使用MyISAM表

1. 事务需要更新大部分或全部数据，表又比较大

2. 事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚



##### 2.4.2 表锁注意事项

1. 使用LOCK TABLES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层──MySQL Server负责的，仅当autocommit=0（不自动提交，默认是自动提交的）、InnoDB_table_locks=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，MySQL Server也才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁，否则，InnoDB将无法自动检测并处理这种死锁。

2. 在用 LOCK TABLES对InnoDB表加锁时要注意，要将AUTOCOMMIT设为0，否则MySQL不会给表加锁；事务结束前，不要用UNLOCK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁。



### 3. 事务

#### 3.1 事务属性

###### 1. 原子性

事务是一个原子操作单元。在当时原子是不可分割的最小元素，其对数据的修改，要么全部成功，要么全部都不成功



###### 2. 一致性

事务开始到结束的时间段内，数据都必须保持一致状态



###### 3. 隔离性

数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的"独立"环境执行



###### 4. 持久性

事务完成后，它对于数据的修改是永久性的，即使出现系统故障也能够保持



#### 3.2 事务常见问题

###### 1. 更新丢失

当多个事务选择同一行操作，并且都是基于最初选定的值，由于每个事务都不知道其他事务的存在，就会发生更新覆盖的问题，类比github提交冲突



###### 2. 脏读

事务A读取了事务B已经修改但尚未提交的数据。若事务B回滚数据，事务A的数据存在不一致性的问题



###### 3. 不可重复读

事务A第一次读取最初数据，第二次读取事务B已经提交的修改或删除数据，导致两次读取数据不一致。



###### 4. 幻读

事务A根据相同条件第二次查询到事务B提交的新增数据，两次数据结果集不一致



### 3. 死锁

#### 3.1 定义

> 当两个事务都需要获得对方持有的排他锁才能继续完成事务



#### 3.2 锁检测机制

> Innodb 通过判断产生死锁中的两个事务，哪一个更小，并回滚较小的事务



事务的大小是通过计算插入、更新或者删除的数据量大小来判断事务大小，但如果跨存储 引擎，则无法检查到死锁。



InnoDB_lock_wait_timeout 参数含义：

* 解决死锁问题

* 解决高并发访问下，大量事务因获取锁等待而占用大量计算机资源，影响性能



#### 3.3 避免死锁的常用方法

1. 如果不同的程序并发存取多个表时，应尽量约定以相同的顺序访问

2. 在程序批量处理数据时，应尽量先对数据排序，以保证每个线程按固定的顺序处理记录

3. 更新记录时，应申请足够级别的锁，即排他锁

4. Repeatable-Read 隔离级别下，两个线程会同时加锁成功。如果在记录不存在的情况插入一条记录，会出现死锁，这时需要使用 Read-Committed 隔离级别。

5. Read-Committed 隔离级别下，第二个线程主键重复出错时，可直接执行插入操作，并捕获主键重复异常，或者执行Rollback释放获得的拍他锁



#### 3.4 死锁排查



<h6>参考资料</h6>

1. [day 59 MySQL之锁、事务、优化](http://py3study.com/Article/details/id/3975.html)
